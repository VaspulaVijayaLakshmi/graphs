class Solution {
public:
    int maximumSafenessFactor(vector<vector<int>>& grid) {

        //mutisoirce bfs
        int n=grid.size();
        int m=grid[0].size();

        if(grid[0][0]==1 || grid[n-1][m-1]==1)
         return 0;

        vector<vector<int>> dir={{-1,0},{1,0},{0,-1},{0,1}};
        vector<vector<int>> dis(n,vector<int>(m,INT_MAX));
        queue<pair<int,int>> q;

        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){

                if(grid[i][j]==1){
                    q.push({i,j});
                    dis[i][j]=0;
                }
                 
            }
        }


        while(!q.empty()){

            auto front=q.front();

            int r=front.first;
            int c=front.second;

            q.pop();

            for(int i=0;i<4;i++){

                int nr=r+dir[i][0];
                int nc=c+dir[i][1];

                if(nr>=0 && nr<n && nc>=0 && nc<m && dis[nr][nc]==INT_MAX){
                     dis[nr][nc]=dis[r][c]+1;
                     q.push({nr,nc});
                  }

                }

            }
        
        //digjistra
        //maxHeap
        priority_queue<pair<int,pair<int,int>>> pq;
        vector<vector<bool>> vis(n, vector<bool>(m, 0));

        pq.push({dis[0][0],{0,0}});
        vis[0][0] = 1;

        while(!pq.empty()){

            auto front=pq.top();

            int sfness=front.first;
            int r=front.second.first;
            int c=front.second.second;

            pq.pop();

            if (r == n - 1 && c == n - 1)
                return sfness;

            for(int i=0;i<4;i++){

                int nr=r+dir[i][0];
                int nc=c+dir[i][1];

                if(nr>=0 && nr<n && nc>=0 && nc<m && !vis[nr][nc]){
                   
                    vis[nr][nc]=true;
                    pq.push({min(dis[nr][nc],sfness),{nr,nc}});
                  }

                }
            
            }

        return 0; 
    }
};


// max safeness factor is the minimum manhattan dis from any cell to any theif

// multi source bfs from all thieves


// first of all ill do multisource bfs and fill the grid.

//now we have dis array , where we have min distances from each theive.

        //now we need to go through the distance array, and find the PATH from 0,0 to n-1,m-1
        //where we will get maximum min manhanttan distance.

        //somwe go through each path in the dis array
        //we cant move to a cell if its marked as 0, as theive occupy that.
        //out of all the paths we need to maintain the min dis
        //and out of all the paths , we need to find the one which have max min safeness factor

        //seems like BS.
        // consider a safeness Factor.
        // and do do bfs or something
        //if its possible
        //increase the safeness factor
        //if thats nt possible decrease the safeness factor.

        //so we take tht safe ness factor and DO the BFS and find the min ??


        //or do digjistra
        //path finding

         //do a digjistra, MAX HEAP.
         //so through the max dis ones and find the min out of that.
         
