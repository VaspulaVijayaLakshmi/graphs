class Solution {
  public:
    vector<int> shortestPath(int n, int m, vector<vector<int>>& edges) {
        
        if(m==0)
         return {-1};
        // Code here
        
        vector<vector<pair<int,int>>> adj(n+1);
        for(auto edge:edges){
            adj[edge[0]].push_back({edge[1],edge[2]});
            adj[edge[1]].push_back({edge[0],edge[2]});
        }
        
        vector<int> dis(n+1,INT_MAX);
        dis[1]=0;
        
        vector<bool> vis(n+1,false);
        vector<int> path(n+1, -1);
        
        priority_queue< pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > pq;
        pq.push({0,1});
        
        while(!pq.empty()){
            
            int currDis=pq.top().first;
            int node=pq.top().second;
            
            pq.pop();
            
            vis[node]=true;
            
            for(auto child:adj[node]){
                
                int cnode=child.first;
                int cdis=child.second;
                
                if(!vis[cnode] && cdis+currDis<dis[cnode]){
                    
                    int totalDis=cdis+currDis;
                    
                    //from which node Ive come from
                    path[cnode]=node;
                    dis[cnode]=totalDis;
                    pq.push({totalDis,cnode});
                    
                }
            }
            
        }
        
         if (dis[n] == INT_MAX) return {-1};
        
        vector<int> res;
    
        int par=n;
        while(par!=-1){
            
            res.push_back(par);
            par=path[par];
            
        }
        
        reverse(res.begin(),res.end());
        res.insert(res.begin(),dis[n]);
        
        return res;
        
        
        
    }
};
