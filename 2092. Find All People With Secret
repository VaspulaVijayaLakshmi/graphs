class Solution {
public:
    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) { 
		// create the graph betwen the persons
        vector<vector<pair<int,int>>> graph(n);
        for(int i = 0; i < meetings.size(); ++i){
            graph[meetings[i][0]].push_back({meetings[i][1],meetings[i][2]});
            graph[meetings[i][1]].push_back({meetings[i][0],meetings[i][2]});
        }

		// using min heap , using time as the sort order key.   
        priority_queue<pair<int,int> , vector<pair<int,int> > , greater<pair<int,int>> > q;
		
		// Add both 0 and firstPerson in the queue as they know the secret initially at time 0 
        q.push({0, firstPerson});
        q.push({0, 0});
		//  vector to store res  
        vector<int> res;
		
		// marking the persons as visited if they have met and shared the secret to all possible persons they could 
        vector<bool> visited(n,false);
        
        while(!q.empty()){
            pair<int,int> curr = q.top();
            q.pop();
            
            int person = curr.second;
            int time = curr.first;
			
			// person had already shared the secret with others
            if(visited[person]) {
                continue;
            }
            visited[person] = true;
			
			//iterate all the meetings of this person and add the potential new persons he can share secret with 
            for(pair<int,int> neigh : graph[person]){
                if(!visited[neigh.first] && time <= neigh.second){
                    q.push({neigh.second,neigh.first});
                }
            }
        }
        
		// all visited persons know the secret
        for(int i = 0; i < n ; ++i ){
            if(visited[i]){
                res.push_back(i);        
            }
        }
        return res;
    }
};

//sort by times also
//build adj matrix with hashmap or something




// n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3

// person -> knows

// 0 - 3
// 1-> 2,3
// 2 -> 1
// 3 -> 0,1


// so now sort the edges by time

// [[1,2,2],[3,1,3],[0,3,3]]

// now 3 knows the secret

// but time 2 -> 1 and 2 both doesnt know
// time = 3 knows

// now go to the people who 3 might know... ->  and spill the secret..

//but the tweak here is -> same timeframe we can tell people from other meetings...

// we are at 3rd min - so we can tell -> [3,1,3],[0,3,3]

// next time onwards...
// all these people will tell their knows. but specified itnervals..

// how to manage time

// ...we dont care as they didnt case max time or min time

//we need to tell most people


//so after 3rd second 

// 3,1,0 knows...so whatever meetings they are in they will spread the info..


// so we will union




// ->But this doesnt work itseems


// Meetings at same time happen simultaneously.
// Means in the same timestamp, information CANNOT chain.

// Example:

// Time 3:

// (A meets B)

// (B meets C)

// At time 3:

// If A knows secret

// A tells B

// But B cannot tell C at time 3, because B learns the secret at the same timestamp, not earlier.

// So secret cannot propagate through multiple meetings inside same timestamp.

// This is why sorting alone isn't enough
// (and why union must not persist beyond a single time window).
