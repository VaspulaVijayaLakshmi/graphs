Uolevi wants to choose a trip that has as many cities as possible.
no directed cycles in the flight network.

First print the maximum number of cities on the route. After this, print the cities in the order they will be visited. You can print any valid solution.

no cyckes so we can egate the edges.
also we need to tell the path 
so we will maintain a par array.


//normal dijstra 

class Solution{

public:

vector<int> topo;
vector<vetor<int>> adj;
vector<bool> visited;

void dfs(vector<vector<int>> &adj, int node){

if(!visited[node]){
for(auto child:adj[node])
   dfs(adj,child);
}

topo.push_back(node);

}


int longestFlightRoute(int n,int m,vector<vector<int>> edges){

adj.resize(n);

for(auto edge:edges){
adj[u].push_back(v);
}

       visited.resize(n+1, false);
        for(int i=1; i<=n; i++) {
            if(!visited[i]) dfs(i, adj, visited, topo);
        }



 reverse(topo.begin(),topo.end());

//after topo sort we have the edges in ordered manner.
//refer notes
//now do prcoess nodes in topo order with dp

const int INF=1e8;

vector<int> dp(n,0);
vector<int> par(n,-1);
dp[0]=1;


      for(int u : topo) {
            if(dp[u] == INT_MIN) continue; // unreachable
            for(int v : adj[u]) {
                if(dp[v] < dp[u] + 1) {
                    dp[v] = dp[u] + 1;
                    parent[v] = u;
                }
            }
        }


 if(dp[n] == INT_MIN) {
            cout << "IMPOSSIBLE\n";
            return;
}

 // Reconstruct path
        vector<int> path;
        for(int cur = n; cur != -1; cur = parent[cur]) path.push_back(cur);
        reverse(path.begin(), path.end());






}



}
